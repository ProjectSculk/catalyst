package dev.sculk.catalyst.tasks

import codechicken.diffpatch.cli.DiffOperation
import codechicken.diffpatch.util.LoggingOutputStream
import dev.sculk.catalyst.util.constants.AT_PATTERN
import dev.sculk.catalyst.util.file
import dev.sculk.catalyst.util.fromString
import dev.sculk.catalyst.util.path
import dev.sculk.catalyst.util.writeLF
import org.cadixdev.at.AccessTransformSet
import org.cadixdev.at.io.AccessTransformFormats
import org.cadixdev.bombe.type.signature.MethodSignature
import org.eclipse.jgit.api.Git
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.logging.LogLevel
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import java.io.PrintStream
import java.nio.file.Path
import kotlin.io.path.*

abstract class RebuildPatches : BaseTask() {
    @get:InputDirectory
    abstract val inputDir: DirectoryProperty
    
    @get:OutputDirectory
    abstract val patchDir: DirectoryProperty
    
    @get:Internal
    abstract val accessTransforms: RegularFileProperty
    
    @get:Internal
    abstract val base: DirectoryProperty
    
    @get:Input
    abstract val contextLines: Property<Int>

    override fun setup() {
        contextLines.convention(3)
    }
    
    override fun run() {
        if (accessTransforms.isPresent) {
            val git = Git.open(inputDir.file)
            generateAt(inputDir.path)
            commitAndTag(git, "SourceAT", "rebuild access transformers")
            git.close()
        }
        
        val printStream = PrintStream(LoggingOutputStream(logger, LogLevel.LIFECYCLE))
        val result = DiffOperation.builder()
            .logTo(printStream)
            .aPath(base.path)
            .bPath(inputDir.path)
            .outputPath(patchDir.path)
            .autoHeader(true)
            .level(codechicken.diffpatch.util.LogLevel.INFO)
            .lineEnding("\n")
            .ignorePrefix(".git")
            .context(contextLines.get())
            .summary(false)
            .build()
            .operate()
        logger.lifecycle("Rebuilt ${result.summary.changedFiles} patches")
    }
    
    @OptIn(ExperimentalPathApi::class) 
    private fun generateAt(input: Path) {
        var set = AccessTransformSet.create()
        if (accessTransforms.path.exists()) {
            set = AccessTransformFormats.FML.read(accessTransforms.path)
        }
        input.walk(PathWalkOption.INCLUDE_DIRECTORIES)
            .filter { f -> f.isRegularFile() && f.extension == "java" }
            .forEach { f ->
                val lines = f.readLines().map { line ->
                    val comment = AT_PATTERN.find(line)
                    if (comment != null) {
                        val at = comment.groupValues[1]
                        val parts = at.split(" ")
                        val name = parts[2]
                        val index = name.indexOf('(')
                        val atClass = set.getOrCreateClass(parts[1])
                        val transform = AccessTransformFormats.FML.fromString(parts[0])
                        if (index == -1) {
                            atClass.mergeField(name, transform)
                        } else {
                            atClass.mergeMethod(MethodSignature.of(
                                name.substring(0, index),
                                name.substring(index)
                            ), transform)
                        }
                        
                        line.replace(AT_PATTERN, "").trimEnd()
                    } else {
                        line
                    }
                }
                f.writeLines(lines)
            }
        AccessTransformFormats.FML.writeLF(accessTransforms.path, set, "# DO NOT EDIT THIS FILE!\n# See the contributing guide on how to add access transformers.")
    }
}
